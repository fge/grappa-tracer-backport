/**
 * Events generated by an {@link
 * com.github.parboiled1.grappa.backport.EventBasedParseRunner}
 *
 * <p>You have hooks at five points in the parsing process:</p>
 *
 * <ul>
 *     <li>before the parsing starts ({@link
 *     com.github.parboiled1.grappa.backport.events.PreParseEvent});</li>
 *     <li>before each match is attempted ({@link
 *     com.github.parboiled1.grappa.backport.events.PreMatchEvent});</li>
 *     <li>after a match has completed, if it is successful ({@link
 *     com.github.parboiled1.grappa.backport.events.MatchSuccessEvent});</li>
 *     <li>after a match has completed, if it fails ({@link
 *     com.github.parboiled1.grappa.backport.events.MatchFailureEvent});</li>
 *     <li>and finally, after the parsing has completed ({@link
 *     com.github.parboiled1.grappa.backport.events.PostParseEvent}).</li>
 * </ul>
 *
 * <p>In order to create your own listener, you extend a {@link
 * com.github.parboiled1.grappa.backport.ParseRunnerListener} and override the
 * methods you need; once done, you initialize it and pass it to an instance of
 * {@link com.github.parboiled1.grappa.backport.EventBasedParseRunner}
 * <em>before</em> you parse your input.</p>
 *
 * <p>For instance, if you have a class named {@code MyParserListener}, you will
 * do this:</p>
 *
 * <pre>
 *     // Create the parser
 *     final MyParser parser = Parboiled.create(MyParser.class);
 *
 *     // Create the listener
 *     final MyParserListener&lt;Foo&gt; listener
 *         = new MyParserListener&lt;&gt;();
 *
 *     // Create the parse runner
 *     final EventBasedParseRunner&lt;Foo&gt; runner
 *         = new EventBasedParseRunner&lt;&gt;(parser.theRule());
 *
 *     // Register the listener
 *     runner.registerListener(listener);
 *
 *     // Run
 *     runner.run(someInput);
 * </pre>
 */
package com.github.parboiled1.grappa.backport.events;
